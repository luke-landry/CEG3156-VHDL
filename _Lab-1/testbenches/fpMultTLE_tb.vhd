-- GENERATED BY CHATGPT
-- Used to save time on unit testing

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL; -- For to_integer and other numeric operations if needed
use IEEE.STD_LOGIC_TEXTIO.ALL; -- For TEXTIO operations if needed for advanced reporting
use STD.TEXTIO.ALL;            -- For TEXTIO operations if needed for advanced reporting

entity fpMultTLE_tb is
end fpMultTLE_tb;

architecture behavioral of fpMultTLE_tb is

    -- Component Declaration for the Unit Under Test (UUT)
    component fpMultTLE is
        Port (
            gClock, gReset : in  std_logic;
            signA, signB : in  std_logic;
            manA, manB : in  std_logic_vector(7 downto 0);
            expA, expB : in std_logic_vector(6 downto 0);
            expOut : out std_logic_vector(6 downto 0);
            manOut : out std_logic_vector(7 downto 0);
            signOut, overFlow : out std_logic
        );
    end component;

    -- Signals for UUT ports
    signal gClock_s, gReset_s : std_logic := '0';
    signal signA_s, signB_s : std_logic;
    signal manA_s, manB_s : std_logic_vector(7 downto 0);
    signal expA_s, expB_s : std_logic_vector(6 downto 0);
    signal expOut_s : std_logic_vector(6 downto 0);
    signal manOut_s : std_logic_vector(7 downto 0);
    signal signOut_s, overFlow_s : std_logic;

    -- Clock period definition
    constant CLOCK_PERIOD : time := 10 ns;

    -- Function to convert std_logic_vector to real for easier verification (if applicable to your FP format)
    -- This is a very simplified example and would need to be tailored to your specific FP format (e.g., bias, hidden bit)
    -- It's often easier to define expected outputs directly as std_logic_vector literals.
    function fp_to_real (
        s    : std_logic;
        exp  : std_logic_vector(6 downto 0);
        man  : std_logic_vector(7 downto 0)
    ) return real is
        variable v_val : real := 0.0;
        variable v_exp : integer;
        variable v_man : real := 0.0;
        constant BIAS : integer := 63; -- Example bias for 7-bit exponent

    begin
        -- Handle special cases like zero, infinity, NaN if your format supports them
        -- For simplicity, this assumes normalized numbers with an implicit '1'
        -- before the mantissa.
        v_exp := to_integer(unsigned(exp)) - BIAS;

        -- Calculate mantissa value (assuming implicit '1')
        v_man := 1.0; -- Implicit leading '1'
        for i in 0 to 7 loop
            if man(7-i) = '1' then
                v_man := v_man + (2.0**(-(real(i+1))));
            end if;
        end loop;

        v_val := v_man * (2.0**real(v_exp));

        if s = '1' then
            v_val := -v_val;
        end if;
        return v_val;
    end function;

begin

    -- Instantiate the Unit Under Test (UUT)
    uut : fpMultTLE
        port map (
            gClock     => gClock_s,
            gReset     => gReset_s,
            signA      => signA_s,
            signB      => signB_s,
            manA       => manA_s,
            manB       => manB_s,
            expA       => expA_s,
            expB       => expB_s,
            expOut     => expOut_s,
            manOut     => manOut_s,
            signOut    => signOut_s,
            overFlow   => overFlow_s
        );

    -- Clock generation process
    clock_gen : process
    begin
        while true loop
            gClock_s <= '0';
            wait for CLOCK_PERIOD / 2;
            gClock_s <= '1';
            wait for CLOCK_PERIOD / 2;
        end loop;
    end process;

    -- Test stimulus process
    stimulus : process
        -- Declare variables for expected outputs
        variable expected_sign : std_logic;
        variable expected_man  : std_logic_vector(7 downto 0);
        variable expected_exp  : std_logic_vector(6 downto 0);
        variable expected_overflow : std_logic;
    begin
        -- 1. Initial Reset
        gReset_s <= '1';
        wait for CLOCK_PERIOD * 2; -- Hold reset for a few clock cycles
        gReset_s <= '0';
        wait for CLOCK_PERIOD;

        -- Test Case 1: Simple Multiplication (e.g., 1.0 * 1.0)
        -- Assuming:
        -- - 7-bit exponent with a bias of 63.
        -- - 8-bit mantissa with an implicit leading '1' for normalized numbers.
        --   So, '00000000' mantissa means 1.0 (1.00000000)
        --   Exponent 0 is represented as 63 (0111111).
        --   Result: 1.0 (sign=0, man="00000000", exp="0111111")
        report "--- Test Case 1: 1.0 * 1.0 ---" severity note;
        signA_s <= '0';
        manA_s  <= "00000000";
        expA_s  <= "0111111"; -- Exponent 0
        signB_s <= '0';
        manB_s  <= "00000000";
        expB_s  <= "0111111"; -- Exponent 0
        wait for CLOCK_PERIOD * 5; -- Allow time for computation (adjust based on your design's latency)

        -- Expected values for Test Case 1
        expected_sign     := '0';
        expected_man      := "00000000";
        expected_exp      := "0111111";
        expected_overflow := '0';

        assert (signOut_s = expected_sign)
            report "Test Case 1 Failed: signOut mismatch. Expected " & std_logic'image(expected_sign) & ", Got " & std_logic'image(signOut_s)
            severity error;
        assert (manOut_s = expected_man)
            report "Test Case 1 Failed: manOut mismatch. Expected " & to_hstring(expected_man) & ", Got " & to_hstring(manOut_s)
            severity error;
        assert (expOut_s = expected_exp)
            report "Test Case 1 Failed: expOut mismatch. Expected " & to_hstring(expected_exp) & ", Got " & to_hstring(expOut_s)
            severity error;
        assert (overFlow_s = expected_overflow)
            report "Test Case 1 Failed: overFlow mismatch. Expected " & std_logic'image(expected_overflow) & ", Got " & std_logic'image(overFlow_s)
            severity error;
        report "Test Case 1 Passed." severity note;
        wait for CLOCK_PERIOD; -- Small delay between tests

        -- Test Case 2: Positive * Negative (e.g., 2.0 * -0.5)
        -- 2.0: sign=0, man="00000000" (1.0), exp="1000000" (exponent 1, biased 64)
        -- -0.5: sign=1, man="00000000" (1.0), exp="0111110" (exponent -1, biased 62)
        -- Result: -1.0
        -- -1.0: sign=1, man="00000000", exp="0111111" (exponent 0, biased 63)
        report "--- Test Case 2: 2.0 * -0.5 ---" severity note;
        signA_s <= '0';
        manA_s  <= "00000000";
        expA_s  <= "1000000";  -- Exponent 1 (63 + 1 = 64)
        signB_s <= '1';
        manB_s  <= "00000000";
        expB_s  <= "0111110";  -- Exponent -1 (63 - 1 = 62)
        wait for CLOCK_PERIOD * 5;

        -- Expected values for Test Case 2
        expected_sign     := '1';
        expected_man      := "00000000";
        expected_exp      := "0111111";
        expected_overflow := '0';

        assert (signOut_s = expected_sign)
            report "Test Case 2 Failed: signOut mismatch. Expected " & std_logic'image(expected_sign) & ", Got " & std_logic'image(signOut_s)
            severity error;
        assert (manOut_s = expected_man)
            report "Test Case 2 Failed: manOut mismatch. Expected " & to_hstring(expected_man) & ", Got " & to_hstring(manOut_s)
            severity error;
        assert (expOut_s = expected_exp)
            report "Test Case 2 Failed: expOut mismatch. Expected " & to_hstring(expected_exp) & ", Got " & to_hstring(expOut_s)
            severity error;
        assert (overFlow_s = expected_overflow)
            report "Test Case 2 Failed: overFlow mismatch. Expected " & std_logic'image(expected_overflow) & ", Got " & std_logic'image(overFlow_s)
            severity error;
        report "Test Case 2 Passed." severity note;
        wait for CLOCK_PERIOD;

        -- Test Case 3: Zero input (e.g., 0.0 * X)
        -- Assuming 0.0 is represented by all zeros: sign='0', man="00000000", exp="0000000"
        -- Result: 0.0
        report "--- Test Case 3: 0.0 * 5.0 ---" severity note;
        signA_s <= '0';
        manA_s  <= (others => '0'); -- All zeros for 0.0
        expA_s  <= (others => '0'); -- All zeros for 0.0
        signB_s <= '0';
        manB_s  <= "01000000";     -- Mantissa for 1.25 (assuming 1.M format, 1.01000000)
        expB_s  <= "1000001";      -- Exponent for 5.0 (2^2 * 1.25 --> exponent 2, biased 65)
        wait for CLOCK_PERIOD * 5;

        -- Expected values for Test Case 3
        expected_sign     := '0';
        expected_man      := (others => '0');
        expected_exp      := (others => '0');
        expected_overflow := '0';

        assert (signOut_s = expected_sign)
            report "Test Case 3 Failed: signOut mismatch. Expected " & std_logic'image(expected_sign) & ", Got " & std_logic'image(signOut_s)
            severity error;
        assert (manOut_s = expected_man)
            report "Test Case 3 Failed: manOut mismatch. Expected " & to_hstring(expected_man) & ", Got " & to_hstring(manOut_s)
            severity error;
        assert (expOut_s = expected_exp)
            report "Test Case 3 Failed: expOut mismatch. Expected " & to_hstring(expected_exp) & ", Got " & to_hstring(expOut_s)
            severity error;
        assert (overFlow_s = expected_overflow)
            report "Test Case 3 Failed: overFlow mismatch. Expected " & std_logic'image(expected_overflow) & ", Got " & std_logic'image(overFlow_s)
            severity error;
        report "Test Case 3 Passed." severity note;
        wait for CLOCK_PERIOD;

        -- Test Case 4: Overflow condition (if applicable to your FP format)
        -- This will depend on the maximum representable exponent.
        -- Example: Large number * Large number
        -- Max exponent (e.g., "1111110" if biased is 63, then actual 62)
        -- Multiplying two numbers close to max should result in overflow.
        report "--- Test Case 4: Overflow example ---" severity note;
        signA_s <= '0';
        manA_s  <= "11111111"; -- Largest mantissa (1.11111111)
        expA_s  <= "1111100";  -- Exponent 61 (biased 124)
        signB_s <= '0';
        manB_s  <= "11111111";
        expB_s  <= "1111100";  -- Exponent 61 (biased 124)
        wait for CLOCK_PERIOD * 5;

        -- Expected values for Test Case 4
        -- If overflow results in max exponent and mantissa, or specific infinity representation
        expected_sign     := '0';
        expected_man      := (others => '0'); -- Common for infinity or a special pattern
        expected_exp      := (others => '1'); -- Often all 1s for infinity/NaN
        expected_overflow := '1';

        assert (signOut_s = expected_sign)
            report "Test Case 4 Failed: signOut mismatch. Expected " & std_logic'image(expected_sign) & ", Got " & std_logic'image(signOut_s)
            severity error;
        -- For overflow, mantissa and exponent might take on specific values like infinity or NaN
        -- You need to know your design's overflow behavior precisely.
        -- For this example, assuming infinity is represented by all 1s in exp and 0s in man.
        assert (manOut_s = expected_man)
            report "Test Case 4 Failed: manOut mismatch for Overflow. Expected " & to_hstring(expected_man) & ", Got " & to_hstring(manOut_s)
            severity error;
        assert (expOut_s = expected_exp)
            report "Test Case 4 Failed: expOut mismatch for Overflow. Expected " & to_hstring(expected_exp) & ", Got " & to_hstring(expOut_s)
            severity error;
        assert (overFlow_s = expected_overflow)
            report "Test Case 4 Failed: overFlow mismatch. Expected " & std_logic'image(expected_overflow) & ", Got " & std_logic'image(overFlow_s)
            severity error;
        report "Test Case 4 Passed." severity note;
        wait for CLOCK_PERIOD;

        -- Test Case 5: Underflow condition (if applicable)
        -- Example: Small number * Small number
        -- Min exponent (e.g., "0000001" if biased is 63, then actual -62)
        report "--- Test Case 5: Underflow example ---" severity note;
        signA_s <= '0';
        manA_s  <= "00000001"; -- Smallest non-zero mantissa
        expA_s  <= "0000010";  -- Exponent -61 (biased 2)
        signB_s <= '0';
        manB_s  <= "00000001";
        expB_s  <= "0000010";
        wait for CLOCK_PERIOD * 5;

        -- Expected values for Test Case 5
        -- If underflow results in zero or denormalized numbers
        expected_sign     := '0';
        expected_man      := (others => '0'); -- Common for underflow to flush to zero
        expected_exp      := (others => '0'); -- Common for underflow to flush to zero
        expected_overflow := '0';             -- Underflow is typically not indicated by 'overFlow' output.
                                               -- You might need a separate 'underFlow' output for this.

        assert (signOut_s = expected_sign)
            report "Test Case 5 Failed: signOut mismatch. Expected " & std_logic'image(expected_sign) & ", Got " & std_logic'image(signOut_s)
            severity error;
        assert (manOut_s = expected_man)
            report "Test Case 5 Failed: manOut mismatch for Underflow. Expected " & to_hstring(expected_man) & ", Got " & to_hstring(manOut_s)
            severity error;
        assert (expOut_s = expected_exp)
            report "Test Case 5 Failed: expOut mismatch for Underflow. Expected " & to_hstring(expected_exp) & ", Got " & to_hstring(expOut_s)
            severity error;
        assert (overFlow_s = expected_overflow) -- Assuming 'overFlow' doesn't cover underflow
            report "Test Case 5 Failed: overFlow mismatch for Underflow. Expected " & std_logic'image(expected_overflow) & ", Got " & std_logic'image(overFlow_s)
            severity error;
        report "Test Case 5 Passed." severity note;
        wait for CLOCK_PERIOD;

        -- Test Case 6: Edge cases for mantissa and exponent (e.g. all 1s, all 0s)
        -- This test case will likely result in a special value (Infinity/NaN or 0.0)
        report "--- Test Case 6: Edge Mantissa and Exponent ---" severity note;
        signA_s <= '1';
        manA_s  <= (others => '1'); -- Largest mantissa (1.11111111)
        expA_s  <= (others => '1'); -- All ones (likely infinity or NaN depending on format)
        signB_s <= '0';
        manB_s  <= (others => '0'); -- All zeros (0.0 for mantissa)
        expB_s  <= (others => '0'); -- All zeros (0.0 for exponent, thus 0.0)
        wait for CLOCK_PERIOD * 5;

        -- Expected values for Test Case 6
        -- This will depend heavily on how your FP unit handles special values.
        -- For a simple example, if anything multiplied by 0.0 is 0.0.
        expected_sign     := '0';
        expected_man      := (others => '0');
        expected_exp      := (others => '0');
        expected_overflow := '0';

        assert (signOut_s = expected_sign)
            report "Test Case 6 Failed: signOut mismatch. Expected " & std_logic'image(expected_sign) & ", Got " & std_logic'image(signOut_s)
            severity error;
        assert (manOut_s = expected_man)
            report "Test Case 6 Failed: manOut mismatch. Expected " & to_hstring(expected_man) & ", Got " & to_hstring(manOut_s)
            severity error;
        assert (expOut_s = expected_exp)
            report "Test Case 6 Failed: expOut mismatch. Expected " & to_hstring(expected_exp) & ", Got " & to_hstring(expOut_s)
            severity error;
        assert (overFlow_s = expected_overflow)
            report "Test Case 6 Failed: overFlow mismatch. Expected " & std_logic'image(expected_overflow) & ", Got " & std_logic'image(overFlow_s)
            severity error;
        report "Test Case 6 Passed." severity note;
        wait for CLOCK_PERIOD;


        report "All test cases completed." severity note;
        wait; -- End of simulation
    end process;

    -- Optional: A process to monitor and display outputs
    -- Keep this for debugging, but the assertions are the primary verification.
    monitor : process (gClock_s)
    begin
        if rising_edge(gClock_s) then
            -- Display current inputs (before computation completes)
            -- This can be useful to see what inputs were applied
            report "TIME: " & to_string(now) & " -- INPUTS: " &
                   "signA=" & std_logic'image(signA_s) & " manA=" & to_hstring(manA_s) & " expA=" & to_hstring(expA_s) &
                   " | signB=" & std_logic'image(signB_s) & " manB=" & to_hstring(manB_s) & " expB=" & to_hstring(expB_s);

            -- Display outputs (after computation completes)
            -- This is useful for identifying issues when an assertion fails
            report "TIME: " & to_string(now) & " -- OUTPUTS: " &
                   "signOut=" & std_logic'image(signOut_s) &
                   ", overFlow=" & std_logic'image(overFlow_s) &
                   ", manOut=" & to_hstring(manOut_s) &
                   ", expOut=" & to_hstring(expOut_s);

            -- Optional: Convert outputs to real for easier understanding in simulation logs
            -- This requires a precise understanding of your FP format.
            -- This function is a placeholder and *must* match your exact FP standard.
            -- report "Output Real: " & real'image(fp_to_real(signOut_s, expOut_s, manOut_s));

        end if;
    end process;

end behavioral;